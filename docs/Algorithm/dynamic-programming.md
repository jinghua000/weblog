# dynamic-programming (动态规划)

## 是什么

动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。（参考[动态规划](https://leetcode-cn.com/tag/dynamic-programming/)）

我个人的理解主要是指把一个问题转换成一个分步递推的子问题过程，适合用于有一定规律性，可以以大化小的问题。

## 例题

首先来引入一个例子，十分常见的爬楼梯问题。

### 例题1

**题目：一个有10层的楼梯，每次可以向上走1步或者2步，一共有多少种走法可以走到。**

如果是一个人类遇到这个问题可能开始进行枚举，比如 

- 1, 1, 1, 1, ...
- 2, 1, 1, 1, ...
- 1, 2, 1, 1, ...

这样虽然花时间但是也可以计算完成的。

而今天要说的动态规划就是换一种思路，尝试把大问题通过某种方式转换成小问题。

**思考**

如果有n阶台阶，那么走到这阶台阶的时候一共有两种可能，一种是1步走上来的，一种是2步走上来的。

假设`走到第n阶台阶的总走法数`为`f(n)`，那么就可以通过上面的思路得到类似的公式

```
f(n) = f(n-1) + f(n-2)
```

这个称之为[`状态转移方程`](https://baike.baidu.com/item/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B)，类似数学中的[`递推公式`](https://baike.baidu.com/item/%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F)。

具体到实例就是说，走到第10层的总走法数量等于走到第8层以及第9层的总走法数量之和。

然后我们知道1层台阶肯定是一种，而2层台阶则会有两种。（1，1或者2）。

所以总结下来是这样的。

```
f(1) = 1
f(2) = 2
f(n) = f(n-1) + f(n-2) (n>=3)
```

接下来就可以根据这个思路进行编码了。

**编码**

根据我们之前得到的公式的第一反应肯定是递归，于是我们尝试使用递归来解决这个问题。

```js
function f (n) {
  if (n <= 2) return n

  return f(n - 1) + f(n - 2)
}
```

可喜可贺，通过公式写递归十分简单，因为我们已经掌握了规律。

——然而。

上面那个类似[`斐波那契数列`](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)的东西复杂度非常的高，其中有相当多的重复运算。

具体来说就是

```
f(10) = f(9) + f(8)
↓
f(9) = f(8) + f(7) / f(8) = f(7) + f(6)
↓
f(8) = f(7) + f(6) / f(7) = f(6) + f(5) / f(7) = f(6) + f(5) / f(6) = f(5) + f(4)
↓
...
```

其中许多项进行了重复的运算，一共的运算次数达到了接近`2^n`，用复杂度来说的话就是`O(2^n)`。

虽然也可以用`hash表`之类的记录已经计算过的值，但是我们还是采取另一种方法吧。

转换一下思考方向，既然知道了`状态转移方程`，那么从小到大一项一项开始加，加到我们需要的那一项不是就好了，于是我们按这个思路来实现一下。

```js
function calc (n) {
  // 我们通常可以使用数组来代替状态转移方程中的函数，也便于理解
  const dp = []

  dp[1] = 1
  dp[2] = 2

  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  
  return dp[n]
}
```

完成了可喜可贺，这样复杂度就降为了`O(n)`，如果是10阶台阶，我们也只要计算10次就好了。

——但是。

上面的解法中创建了一个长度为`n`的数组，空间复杂度是`O(n)`。

但是事实上我们这道题目不需要花费这么大的空间，因为我们需要用到的量只有`当前的`，以及`前一个`，`前两个`这3个量，所以更简化的方法是。

```js
function calc2 (n) {
  if (n <= 2) return n

  let first = 1, second = 2, sum

  for (let i = 3; i <= n; i++) {
    sum = first + second
    first = second
    second = sum
  }

  return sum
}
```

好了，因为一共只使用了3个变量，这样一来我们的空间复杂度便下降成了`O(1)`。最终以时间复杂度`O(n)`，空间复杂度`O(1)`完成了这个问题，可喜可贺。

上面这道题目对应的[LeetCode地址](https://leetcode-cn.com/problems/climbing-stairs/)。

### 例题2

**题目：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**

**给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。**

举例就是说，如果金额数组是`[10, 1, 5, 3]`，那么最佳路线就是`10 -> 5`，最高金额就是`15`。

如果金额数组是`[10, 1, 5, 10]`, 那么最佳路线就是`10 -> 10`, 最高金额就是`20`。

**思考**

莫非小偷也要会算法？

不我们要思考的不是这个，是如何才能偷最多的钱。

这个问题直观上是隔着偷就行了，但是比如`[2, 1, 1, 2]`这种就不能这么简单的来了，来尝试一下能不能动态规划吧。

比如我在一个房子的屋顶上，只有两种选择

- 如果我偷了他，我就不能偷前一家，我的最大金额会是之前的金额加上这间房子的金额。
- 如果我不偷他，那么我的最大金额就不会变。

那么我们就设定一个动态规划的对象，假设`f(n)`是`到这个房子为止所能偷到的最大金额`。根据上面的选择我们可以得出`状态转移方程`。

```
f(n) = Math.max(f(n-1), f(n-2) + currentMoney)
```

这个就比较抽象了，不像是第一道题那样的递推公式。

当前这个房子为止能偷到的最大的金额是

> 到前一家为止偷到的最大金额（注意这个概念，并不是前一家的金额），以及到前两家为止偷到的最大金额加上本家金额之和，取两者中比较大的一个。

能想到这个应该是最关键的一点，动态规划经常需要使用比较抽象的概念把前后状态连接起来。

## 参考

- 题目1
- 题目2
- [LeetCode探索初级算法 - 动态规划](https://zhuanlan.zhihu.com/p/49427827)
- [漫画：什么是动态规划？（整合版）](https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg)