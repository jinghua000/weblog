# dynamic-programming (动态规划)

## 是什么

动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。（参考[动态规划](https://leetcode-cn.com/tag/dynamic-programming/)）

我个人的理解主要是指把一个问题转换成一个分步递推的子问题过程，适合用于有一定规律性，可以以大化小的问题。

## 例题

首先来引入一个例子，十分常见的爬楼梯问题。

### 例题1

**题目：一个有10层的楼梯，每次可以向上走1步或者2步，一共有多少种走法可以走到。**

如果是一个人类遇到这个问题可能开始进行枚举，比如 

- 1, 1, 1, 1, ...
- 2, 1, 1, 1, ...
- 1, 2, 1, 1, ...

这样虽然花时间但是也可以计算完成的。

而今天要说的动态规划就是换一种思路，尝试把大问题通过某种方式转换成小问题。

**思考**

如果有n阶台阶，那么走到这阶台阶的时候一共有两种可能，一种是1步走上来的，一种是2步走上来的。

假设走到第n阶台阶的总走法数为`f(n)`，那么就可以通过上面的思路得到类似的公式

```
f(n) = f(n-1) + f(n-2)
```

这个称之为[`状态转移方程`](https://baike.baidu.com/item/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B)，类似数学中的[`递推公式`](https://baike.baidu.com/item/%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F)。

具体到实例就是说，走到第10层的总走法数量等于走到第8层以及第9层的总走法数量之和。

然后我们知道1层台阶肯定是一种，而2层台阶则会有两种。（1，1或者2）。

所以总结下来是这样的。

```
f(1) = 1
f(2) = 2
f(n) = f(n-1) + f(n-2) (n>=3)
```

接下来就可以根据这个思路进行编码了。

**编码**

根据我们之前得到的公式的第一反应肯定是递归，于是我们尝试使用递归来解决这个问题。

```js
function f (n) {
  if (n <= 2) return n

  return f(n - 1) + f(n - 2)
}
```

可喜可贺，通过公式写递归十分简单，因为我们已经掌握了规律。

——然而。

上面那个类似[`斐波那契数列`](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)的东西复杂度非常的高，其中有相当多的重复运算。

具体来说就是

```
f(10) = f(9) + f(8)
↓
f(9) = f(8) + f(7) / f(8) = f(7) + f(6)
↓
f(8) = f(7) + f(6) / f(7) = f(6) + f(5) / f(7) = f(6) + f(5) / f(6) = f(5) + f(4)
↓
...
```

其中许多项进行了重复的运算，一共的运算次数达到了接近`2^n`，用复杂度来说的话就是`O(2^n)`。

虽然也可以用`hash表`之类的记录已经计算过的值，但是我们还是采取另一种方法吧。

转换一下思考方向，既然知道了`状态转移方程`，那么从小到大一项一项开始加，加到我们需要的那一项不是就好了，于是我们按这个思路来实现一下。

```js
function calc (n) {
  // 我们通常可以使用数组来代替状态转移方程中的函数，也便于理解
  const dp = []

  dp[1] = 1
  dp[2] = 2

  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  
  return dp[n]
}
```

完成了可喜可贺，这样复杂度就降为了`O(n)`，如果是10阶台阶，我们也只要计算10次就好了。

——但是。

上面的解法中创建了一个长度为`n`的数组，空间复杂度是`O(n)`。

但是事实上我们这道题目不需要花费这么大的空间，因为我们需要用到的量只有`当前的`，以及`前一个`，`前两个`这3个量，所以更简化的方法是。

```js
function calc2 (n) {
  if (n <= 2) return n

  let first = 1, second = 2, sum

  for (let i = 3; i <= n; i++) {
    sum = first + second
    first = second
    second = sum
  }

  return sum
}
```

好了，因为一共只使用了3个变量，这样一来我们的空间复杂度便下降成了`O(1)`。最终以时间复杂度`O(n)`，空间复杂度`O(1)`完成了这个问题，可喜可贺。

上面这道题目对应的[LeetCode地址](https://leetcode-cn.com/problems/climbing-stairs/)。

## 参考

- [LeetCode探索初级算法 - 动态规划](https://zhuanlan.zhihu.com/p/49427827)
- [漫画：什么是动态规划？（整合版）](https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg)