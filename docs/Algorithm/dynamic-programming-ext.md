# dynamic-programming-ext (动态规划-附加)

这里是对之前[动态规划](./dynamic-programming.md)的一些补充。

## 题目1 - 最大正方形

**题目**

**在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。**

比如

```
输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

> 输入的实际内容为 `[["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]`

**思考**

这个题目最直观的做法是依次循环每一个元素，假设从左上开始遍历，如果找到`1`则再从那个点向下向右找每次新找一行，看是不是那一行的所有元素都为`1`，最后记录下最长的边长，边长乘以边长就是正方形的面积了。

不过这样复杂度比较高，所以我们来考虑有没有复杂度更低的算法。

假设我们从左上开始遍历，那么遍历完成到最后就是右下，那么我们考虑把右下的点作为正方形的右下角看他们之间是否有关联。

当一个点表示`以这点为右下角的正方形`时，这一点的正方形的面积，有以下两种情况。

1. 如果是0则面积为0
2. 如果不是0，则面积为`上方的点对应的正方形`，`左方的点对应的正方形`，`左上方的点对应的正方形`，这3者中最小的一个正方形的边长+1的边长的正方形的面积。

如果能考虑到第二种情况的话，那么我们就可以以`某个点为正方形右下角的边长`进行动态规划

```
dp(x, y) = min(dp(x - 1, y), dp(x, y - 1), dp(x - 1, y - 1)) + 1
```

且当`x`或者`y`为0的时候，`dp(x, y)`的最大值为`1`。

如果我们按照刚刚的思路对于最上面的例子，得到的结果是这样的

```

1 0 1 0 0
1 0 1 1 1
1 1 1 2 2
1 0 0 1 0

```

可见最大的正方形边长是`2`，那么最大的正方形面积就是`4`。

代码实现如下：

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
  if (!matrix.length) return 0

  // 创建一个和原本一模一样大小的二维数组
  const dp = Array(matrix.length).fill(0).map(
    () => Array(matrix[0].length).fill(0)
  )

  let max = 0
  for (let x = 0; x < matrix.length; x++) {
    for (let y = 0; y < matrix[x].length; y++) {
      // 如果对应元素为0则跳过
      if (!+matrix[x][y]) continue

      // 如果是最上或者最左边的元素则边长为1，否则带入状态转移方程
      if (x === 0 || y === 0) {
        dp[x][y] = 1
      } else {
        dp[x][y] = Math.min(dp[x - 1][y], dp[x][y - 1], dp[x - 1][y - 1]) + 1
      }

      max = Math.max(dp[x][y], max)
    }
  }

  return max * max
};
```

这样之后我们就通过动态规划的方式实现了时间复杂度`O(mn)`（遍历了每一个元素）空间复杂度`O(mn)`（创建了一个`mn`大小的二维数组）的算法。

然后我们注意到，每次对一个元素进行计算时，只关系到其`左`，`上`，`左上`的第一个元素，意思就是说只关系到当前这一行数据以及上一行数据，所以我们不需要创建一个`mn`大小的数组，只需要创建两个长度为`n`的数组就可以了。

空间优化的代码如下：

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
  if (!matrix.length) return 0

  // 只创建第一行的动态规划数组
  const dp = Array(matrix[0].length).fill(0)
  let max = 0

  for (let x = 0; x < matrix.length; x++) {
    // 每次遍历下一行之前先复制上一行数组
    let tmp = [].concat(dp)
    for (let y = 0; y < matrix[x].length; y++) {
      if (+matrix[x][y]) {

        if (x === 0 || y === 0) {
          dp[y] = 1
        } else {
          dp[y] = Math.min(dp[y - 1], tmp[y - 1], tmp[y]) + 1
        }
        
      } else {
        dp[y] = 0
      }

      max = Math.max(dp[y], max)
    }
  }

  return max * max
};
```

这样一来空间复杂度就优化成了`O(n)`，当然还有一种方式是可以修改原本数组达到空间复杂度`O(1)`，不过那样会对原始数据进行修改我们这里就不这样做了。

最后我们以时间复杂度`O(mn)`，空间复杂度`O(n)`完成了这道题目。

## 题目2 - 两个字符串的删除操作

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

**示例：**

```
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

### 思路

直接计算相差的字符可能没那么好想到，不过如果去思考最长的公共子序列的话就比较好理解了。

```
需要删除的操作 = word1长度 + word2长度 - 2 * 最长公共子序列的长度
```

那么问题就变成了计算最长公共子序列了，看到这种最什么什么的情况就需要先考虑一下动态规划了，看问题是否可以以大化小。

我们可以利用以下的逻辑进行最长子序列的计算，数字表示到某一位为止匹配到的最长子序列长度。

```
    a   b   c   d   e
d   0   0   0   1   1

a   1   1   1   1   1

d   1   1   1   2   2

c   1   1   2   2   2

e   1   1   2   2   3

最长子序列为3
```

具体算法描述如下

1. 从字符串1的第一位开始遍历
2. 如果与字符串2的某个字符相等
3. 则最长子序列等于到前个位置为止的字符串1与到前个位置为止的字符串2的最长子序列加1
4. 否则，则最长子序列等于当前字符串1的上一位最长子序列或者上次匹配到当前位的最长子序列中较大的一个

光用逻辑确实太抽象，两种情况分别举例就是这样

1. 比如两个字符串：str1 = abc，str2 = abcd
2. 此时的最长子序列是3，假设现在str1再加一位
3. 如果是d的话则最长子序列等于abc与abcd的最长子序列加1，也就是4
4. 如果不是d是x，则最长子序列等于abc与abcd的最长子序列，或者abcx与abcd的最长子序列中较大的一个
5. 上面的例子用到条件一，条件二主要作用是在一次匹配中，匹配到字符之后再把数据往后一位带，比如图上的da匹配ab时，da首先匹配a匹配到了，再匹配ab的时候把之前的状态带上，而不是计算d与ab的最长子序列。

然后因为其实每次只需要到当前字符为止的最长子序列状态，以及到前一个字符的为止的最长子序列状态，所以不需要创建一个m * n的矩阵，只需要两个n的数组即可。

### 代码

代码实现如下：

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    let m = word1.length
    let n = word2.length
    // 创建一个比长度n+1的数组，用于边界条件判断
    let dp = Array(n + 1).fill(0), temp

    for (let i = 0; i < m; i++) {
        // temp表示上次的状态
        temp = dp
        // 初始化本次的状态
        dp = Array(n + 1).fill(0)

        for (let j = 0; j < n; j++) {
            // 如果当前匹配到的字符一样，则当前最长子序列等于到前一个字符为止的最长子序列长度加1
            if (word2[j] === word1[i]) {
                dp[j + 1] = temp[j] + 1
            // 否则等于匹配到上一位的最长子序列长度 或者 上次匹配到此处的最长子序列长度 中较大的一个
            } else {
                dp[j + 1] = Math.max(dp[j], temp[j + 1])
            }
        }
    }

    return m + n - 2 * dp[n]
};
```

这样算法的时间复杂度是`O(mn)`, 空间复杂度是`O(n)`。

## 参考

- [题目1 - 最大正方形](https://leetcode-cn.com/problems/maximal-square/)
- [题目2 - 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)