# backtracking (回溯算法)

## 是什么

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。

基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。

一般表现形式是用递归的去寻找符合的条件。

## 例子1 - 全排列

题目：给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

示例：

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

从我们小学2年级就学过的排列组合中可以得知，3个不同数的排列组合的可能性是：

```
3! = 3 * 2 * 1 = 6
```

而这一类问题就可以使用回溯解决。

算法的思路大概可以表述为以下这样。

1. 维护一个当前访问过的数的集合
2. 访问没有访问过第一个数，把访问的数设置为已访问
3. 再访问下一个没访问的数，直到全部访问完毕
4. 把最后一位设为未访问，之后回退一步，再对下一个没访问的数再执行以上操作

光使用文字确实也是十分难以理解，用流程大概是这样

1. 已访问：`[]`
2. 已访问：`[1]`
3. 已访问：`[1, 2]` 
4. 已访问：`[1, 2, 3]` => 结果1
5. 已访问：`[1, 2]` 
6. 已访问：`[1]`
7. 已访问：`[1, 3]`
8. 已访问：`[1, 3, 2]` => 结果2
9. 已访问：`[1, 3]`
10. 已访问：`[1]`
11. 已访问：`[]`
12. 已访问：`[2]`
13. 已访问：`[2, 1]`
14. 已访问：`[2, 1, 3]` => 结果3
15. 已访问：`[2, 1]`
16. 已访问：`[2]`
17. 已访问：`[2, 3]`
18. 已访问：`[2, 3, 1]` => 结果4
19. ...

代码实现：

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const length = nums.length
    const result = []
    const visited = Array(length).fill(false)

    loop([])

    return result 

    function loop (arr) {
        if (arr.length === nums.length) {
            result.push(arr.slice())
            return 
        }

        for (let i = 0; i < nums.length; i++) {
            if (visited[i]) continue

            // 将当前位设置为已访问
            visited[i] = true
            // 把当前数字暂存起来
            arr.push(nums[i])

            loop(arr)

            // 去除最后一个数字
            arr.pop()
            // 将当前位设置为未访问
            visited[i] = false
        }
    }
};
```

## 参考

- [全排列](https://leetcode-cn.com/problems/permutations/)
- [LeetCode Backtracking](https://leetcode-cn.com/tag/backtracking/)