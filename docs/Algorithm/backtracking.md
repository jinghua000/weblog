# backtracking (回溯算法)

## 是什么

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。

基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。

一般表现形式是用递归的去寻找符合的条件。

## 例题1 - 全排列

题目：给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

示例：

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

从我们小学2年级就学过的排列组合中可以得知，3个不同数的排列组合的可能性是：

```
3! = 3 * 2 * 1 = 6
```

而这一类问题就可以使用回溯解决。

算法的思路大概可以表述为以下这样。

1. 维护一个当前访问过的数的集合
2. 访问没有访问过第一个数，把访问的数设置为已访问
3. 递归的调用步骤2
4. 如果长度等于数组长度，则把此时的集合加入结果中
5. 从集合去除最后一个访问过的数，把那个数设置为未访问
6. 返回结果

光使用文字确实也是十分难以理解，用流程大概是这样

1. 已访问：`[]`
2. 已访问：`[1]`
3. 已访问：`[1, 2]` 
4. 已访问：`[1, 2, 3]` => 结果1
5. 已访问：`[1, 2]` 
6. 已访问：`[1]`
7. 已访问：`[1, 3]`
8. 已访问：`[1, 3, 2]` => 结果2
9. 已访问：`[1, 3]`
10. 已访问：`[1]`
11. 已访问：`[]`
12. 已访问：`[2]`
13. 已访问：`[2, 1]`
14. 已访问：`[2, 1, 3]` => 结果3
15. 已访问：`[2, 1]`
16. 已访问：`[2]`
17. 已访问：`[2, 3]`
18. 已访问：`[2, 3, 1]` => 结果4
19. ...

代码实现：

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const length = nums.length
    const result = []
    const visited = Array(length).fill(false)

    loop([])

    return result 

    function loop (arr) {
        if (arr.length === nums.length) {
            result.push(arr.slice())
            return 
        }

        for (let i = 0; i < nums.length; i++) {
            if (visited[i]) continue

            // 将当前位设置为已访问
            visited[i] = true
            // 把当前数字暂存起来
            arr.push(nums[i])

            loop(arr)

            // 去除最后一个数字
            arr.pop()
            // 将当前位设置为未访问
            visited[i] = false
        }
    }
};
```

找到一个结果的次数是n，而一共有n!种结果，这个算法的时间复杂度基本是O(n * n!)。

空间复杂度除了储存以及维护是否访问的数组都是n外，递归函数栈最多也有n层，空间复杂度是O(n)。

## 例题2 - N皇后

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给定一个整数 n，返回 n 皇后不同的解决方案的数量。

示例:

```
输入: 4
输出: 2
解释: 4 皇后问题存在如下两个不同的解法。
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
```

这个问题乍一看非常的复杂，最直观的做法是枚举每一个格子上都可能存在皇后的情况，但这种复杂度非常高，所以我们需要用一些手段来进行优化。

这就涉及到国际象棋规则的问题了，我们都知道一个皇后可以横着竖着斜着走任意格子，要保证相互间不能攻击，那么意味着每一行，一列，左上到右下的斜线，右上到左下的斜线上最多只有一个皇后。

行与列非常好表示，假设某个皇后坐标是(x, y)那么一行就是(x, n)，一列就是(n, y)，n为任意值。

而两条斜线就需要涉及一些数学运算了，假设坐标(x, y)，那么有且仅有左上到右下的对角线上的所有坐标(xn, yn)满足条件`xn - yn = x - y`。

这就比如坐标是`1,1`，那么`0,0`、`2,2`、`3,3`全部都是和`1,1`在一条斜线上的。

而有且仅有右上到左下的所有坐标(xn, yn)满足条件`xn + yn = x + y`。

比如坐标`1,1`，那么`2,0`、`0,2`，都是和`1,1`在一条斜线上。

用图来表示就是。

```
[
    [1, 0, 1, 0],
    [0, 1, 0, 0],
    [1, 0, 1, 0],
    [0, 0, 0, 1],
]
```

这样之后我们就有了大致的思路了，大概算法过程描述如下。

1. 从上到下遍历每一行
2. 依次遍历每一列，维护3个集合，分别是列坐标，两个坐标相加，两个坐标相减
3. 如果当前坐标在上述集合中则跳过
4. 把当前坐标加入3个集合
5. 以步骤1递归调用下一行
6. 把当前坐标从集合中删除
7. 如果遍历到最后一行，则结果加1
8. 返回结果

代码实现：

```js
/**
 * @param {number} n
 * @return {number}
 */
var totalNQueens = function(n) {
    const cols = new Set()
    const diag1 = new Set()
    const diag2 = new Set()

    return loop(0)

    function loop(row) {
        if (row === n) {
            return 1
        }

        let result = 0

        for (let col = 0; col < n; col++) {
            if (cols.has(col)) {
                continue 
            }

            // 左上到右下的对角线
            const pos1 = row - col
            if (diag1.has(pos1)) {
                continue
            }

            // 右上到左下的对角线
            const pos2 = row + col
            if (diag2.has(pos2)) {
                continue
            }

            cols.add(col)
            diag1.add(pos1)
            diag2.add(pos2)

            result += loop(row + 1)

            cols.delete(col)
            diag1.delete(pos1)
            diag2.delete(pos2)
        }

        return result
    }
};
```

这样的时间复杂度基本为O(n!)，空间复杂度为O(n)。

## 总结

回溯算法的时间复杂度基本都比较高，一般用于寻找所有可能情况时使用。

另外有一点可以注意的是当递归层很多的时候，可以把状态的引用当做参数传递给递归函数，比如：

```js
function loop(n, state) {
    // ...
    loop(n + 1, state)
}
```

这样做的一个好处是可以减少许多作用域的查询次数，比如一个10层的递归，那么要访问最外层作用域的某个状态则需要向上访问10层，但是如果有引用则只需要访问一次。

但是这样的问题就是会多创建n次引用，n为函数栈深度，从而增加空间消耗。

## 参考

- [N皇后](https://leetcode-cn.com/problems/n-queens-ii/)
- [全排列](https://leetcode-cn.com/problems/permutations/)
- [LeetCode Backtracking](https://leetcode-cn.com/tag/backtracking/)